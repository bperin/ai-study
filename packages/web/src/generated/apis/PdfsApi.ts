/* tslint:disable */
/* eslint-disable */
/**
 * Dash AI API
 * The Dash AI API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type { ChatMessageDto, GenerateFlashcardsDto, ObjectiveResponseDto, PaginatedPdfResponseDto } from '../models/index';
import { ChatMessageDtoFromJSON, ChatMessageDtoToJSON, GenerateFlashcardsDtoFromJSON, GenerateFlashcardsDtoToJSON, ObjectiveResponseDtoFromJSON, ObjectiveResponseDtoToJSON, PaginatedPdfResponseDtoFromJSON, PaginatedPdfResponseDtoToJSON } from '../models/index';

export interface PdfsControllerAutoGenerateTestPlanRequest {
  id: string;
}

export interface PdfsControllerChatPlanRequest {
  chatMessageDto: ChatMessageDto;
}

export interface PdfsControllerDeletePdfRequest {
  id: string;
}

export interface PdfsControllerGenerateFlashcardsRequest {
  id: string;
  generateFlashcardsDto: GenerateFlashcardsDto;
}

export interface PdfsControllerGetObjectivesRequest {
  id: string;
}

export interface PdfsControllerListAllPdfsRequest {
  page: number;
  limit: number;
}

export interface PdfsControllerListPdfsRequest {
  page: number;
  limit: number;
}

/**
 *
 */
export class PdfsApi extends runtime.BaseAPI {
  /**
   * Auto-generate initial test plan from PDF content
   */
  async pdfsControllerAutoGenerateTestPlanRaw(requestParameters: PdfsControllerAutoGenerateTestPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling pdfsControllerAutoGenerateTestPlan.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/pdfs/{id}/auto-generate-plan`.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Auto-generate initial test plan from PDF content
   */
  async pdfsControllerAutoGenerateTestPlan(requestParameters: PdfsControllerAutoGenerateTestPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
    await this.pdfsControllerAutoGenerateTestPlanRaw(requestParameters, initOverrides);
  }

  /**
   * Chat with AI to plan test generation
   */
  async pdfsControllerChatPlanRaw(requestParameters: PdfsControllerChatPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.chatMessageDto === null || requestParameters.chatMessageDto === undefined) {
      throw new runtime.RequiredError('chatMessageDto', 'Required parameter requestParameters.chatMessageDto was null or undefined when calling pdfsControllerChatPlan.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/pdfs/chat`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: ChatMessageDtoToJSON(requestParameters.chatMessageDto),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Chat with AI to plan test generation
   */
  async pdfsControllerChatPlan(requestParameters: PdfsControllerChatPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
    await this.pdfsControllerChatPlanRaw(requestParameters, initOverrides);
  }

  /**
   * Delete a PDF and all associated data (Admin only)
   */
  async pdfsControllerDeletePdfRaw(requestParameters: PdfsControllerDeletePdfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling pdfsControllerDeletePdf.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/pdfs/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a PDF and all associated data (Admin only)
   */
  async pdfsControllerDeletePdf(requestParameters: PdfsControllerDeletePdfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
    await this.pdfsControllerDeletePdfRaw(requestParameters, initOverrides);
  }

  /**
   * Generate flashcards from a PDF
   */
  async pdfsControllerGenerateFlashcardsRaw(requestParameters: PdfsControllerGenerateFlashcardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling pdfsControllerGenerateFlashcards.');
    }

    if (requestParameters.generateFlashcardsDto === null || requestParameters.generateFlashcardsDto === undefined) {
      throw new runtime.RequiredError('generateFlashcardsDto', 'Required parameter requestParameters.generateFlashcardsDto was null or undefined when calling pdfsControllerGenerateFlashcards.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/pdfs/{id}/generate`.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GenerateFlashcardsDtoToJSON(requestParameters.generateFlashcardsDto),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Generate flashcards from a PDF
   */
  async pdfsControllerGenerateFlashcards(requestParameters: PdfsControllerGenerateFlashcardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
    await this.pdfsControllerGenerateFlashcardsRaw(requestParameters, initOverrides);
  }

  /**
   * Get generated objectives and questions for a PDF
   */
  async pdfsControllerGetObjectivesRaw(requestParameters: PdfsControllerGetObjectivesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ObjectiveResponseDto>>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling pdfsControllerGetObjectives.');
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/pdfs/{id}/objectives`.replace(`{${'id'}}`, encodeURIComponent(String(requestParameters.id))),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ObjectiveResponseDtoFromJSON));
  }

  /**
   * Get generated objectives and questions for a PDF
   */
  async pdfsControllerGetObjectives(requestParameters: PdfsControllerGetObjectivesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ObjectiveResponseDto>> {
    const response = await this.pdfsControllerGetObjectivesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all PDFs from all users (for taking tests)
   */
  async pdfsControllerListAllPdfsRaw(requestParameters: PdfsControllerListAllPdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPdfResponseDto>> {
    if (requestParameters.page === null || requestParameters.page === undefined) {
      throw new runtime.RequiredError('page', 'Required parameter requestParameters.page was null or undefined when calling pdfsControllerListAllPdfs.');
    }

    if (requestParameters.limit === null || requestParameters.limit === undefined) {
      throw new runtime.RequiredError('limit', 'Required parameter requestParameters.limit was null or undefined when calling pdfsControllerListAllPdfs.');
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/pdfs/all`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPdfResponseDtoFromJSON(jsonValue));
  }

  /**
   * List all PDFs from all users (for taking tests)
   */
  async pdfsControllerListAllPdfs(requestParameters: PdfsControllerListAllPdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPdfResponseDto> {
    const response = await this.pdfsControllerListAllPdfsRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * List all PDFs for the user with pagination
   */
  async pdfsControllerListPdfsRaw(requestParameters: PdfsControllerListPdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPdfResponseDto>> {
    if (requestParameters.page === null || requestParameters.page === undefined) {
      throw new runtime.RequiredError('page', 'Required parameter requestParameters.page was null or undefined when calling pdfsControllerListPdfs.');
    }

    if (requestParameters.limit === null || requestParameters.limit === undefined) {
      throw new runtime.RequiredError('limit', 'Required parameter requestParameters.limit was null or undefined when calling pdfsControllerListPdfs.');
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearer', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/pdfs`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPdfResponseDtoFromJSON(jsonValue));
  }

  /**
   * List all PDFs for the user with pagination
   */
  async pdfsControllerListPdfs(requestParameters: PdfsControllerListPdfsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPdfResponseDto> {
    const response = await this.pdfsControllerListPdfsRaw(requestParameters, initOverrides);
    return await response.value();
  }
}
